from typing import List, Union, Callable

import numpy as np
from sumolib.net import Net as SumolibNet

from evi.triggers import (
    TriggerCollection,
    Trigger,
    TriggerEvent,
)

from ..route.abstract_ego_route import AbstractEgoRoute, AbstractEgoRouteLane
from .abstract_meta_trigger import AbstractMetaTrigger


TriggerOrMetaTrigger = Union[AbstractMetaTrigger, Trigger]


class TriggerGenerator:
    """
    Helps generating triggers along a predefined route.
    """

    def __init__(
            self,
            ego_route: AbstractEgoRoute,
            sumolib_net: SumolibNet,
            sumo_version: str,
            triggers_max_radius: float,
            default_vehicle_type: str,
            events_at_every_lane: List[TriggerEvent] = None,
            events_by_route_index: Callable[
                [int, AbstractEgoRouteLane], List[TriggerEvent]
            ] = None,
            triggers_at_every_lane: List[TriggerOrMetaTrigger] = None,
            triggers_by_route_index: Callable[
                [int, AbstractEgoRouteLane], List[TriggerOrMetaTrigger]
            ] = None,
            triggers_default_offset: float = 0,
            triggers_seed: int = None,
    ):
        """
        :param ego_route:
        :param sumolib_net:
        :param sumo_version:
        :param triggers_max_radius:
        :param default_vehicle_type:
        :param events_at_every_lane:
        :param events_by_route_index:
        :param triggers_at_every_lane:
        :param triggers_by_route_index:
        :param triggers_default_offset: For each lane, in addition to any
            custom triggers, one trigger
            will be generated by default. This value defines its offset from
            the start of its lane.
            If the offset is less than 0 or longer than the edge itself,
            the trigger will be placed beyond the edge on the straight
            imagined line that would extend that edge in the direction of the
            respective lane segment.
        """
        self.sumo_version = sumo_version
        self.ego_route = ego_route
        self.events_at_every_lane = (
            events_at_every_lane
            if events_at_every_lane is not None else []
        )
        self.events_by_route_index = (
            events_by_route_index
            if events_by_route_index is not None
            else lambda route_elem_index, ego_route_lane: []
        )
        self.triggers_at_every_lane = (
            triggers_at_every_lane
            if triggers_at_every_lane is not None else []
        )
        self.triggers_by_route_index = (
            triggers_by_route_index
            if triggers_by_route_index is not None
            else lambda route_elem_index, ego_route_lane: []
        )
        self.triggers_default_offset = triggers_default_offset
        self.seed = triggers_seed

        # For obtaining the lengths of lanes:
        self.net = sumolib_net

        self.trigger_collection = TriggerCollection(
            triggers_max_radius=triggers_max_radius,
            default_vehicle_type=default_vehicle_type,
            triggers_filename=None  # not loading any triggers
        )

    def save(self, filename: str):
        self.trigger_collection.save(filename)

    def generate(self):
        """
        Generate new triggers and events, then insert them into the
        TriggerCollection.
        """
        random_state = np.random.get_state()
        # ^ for resetting later if seed is set
        if self.seed is not None:
            np.random.seed(self.seed)

        for route_elem_index, ego_route_lane in enumerate(
                self.ego_route.lanes):
            # One default trigger at the beginning of this edge for appending
            # spawn events, just so we can avoid creating too many individual
            # triggers in the same place:
            offset = self.triggers_default_offset
            eh = self.ego_route.get_edge_helper(route_elem_index)
            if 0 <= offset <= eh.length:
                ego_xy, _, _ = eh.get_cartesian_and_direction_and_angle_at(
                    offset
                )
            else:
                edge_start, direction, _ = (
                    eh.get_cartesian_and_direction_and_angle_at(
                        0 if offset < 0 else eh.length
                    )
                )
                ego_xy = np.array(edge_start) + direction * offset
            default_trigger = Trigger(
                note="Default trigger",
                ego_xy=tuple(ego_xy)
            )
            self.trigger_collection.triggers.append(default_trigger)

            default_trigger.events.extend(self.events_at_every_lane)
            default_trigger.events.extend(
                self.events_by_route_index(route_elem_index, ego_route_lane)
            )
            # TODO: use copies of events?

            new_triggers_or_meta = self.triggers_by_route_index(
                route_elem_index,
                ego_route_lane
            )
            new_triggers_or_meta += self.triggers_at_every_lane
            new_triggers = [
                t.copy()
                for t in new_triggers_or_meta
                if isinstance(t, Trigger)
            ]
            for mt in new_triggers_or_meta:
                if not isinstance(mt, AbstractMetaTrigger):
                    continue
                new_triggers.extend(mt.generate_triggers(
                    route_elem_index=route_elem_index,
                    ego_route_lane=ego_route_lane,
                    default_trigger=default_trigger
                ))

            # TODO: count stats of new_triggers here?
            self.trigger_collection.triggers.extend(new_triggers)

        if self.seed is not None:
            np.random.set_state(random_state)
